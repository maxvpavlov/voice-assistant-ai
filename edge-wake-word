#!/usr/bin/env python3
"""
edge-wake-word - Voice Assistant CLI Tool
Train, test, and run wake word detection on edge devices.
"""

import sys
import argparse
import signal
import time
from pathlib import Path

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent / "src"))

from voice_assistant import WakeWordDetector, AudioRecorder, ModelTrainer


class EdgeWakeWord:
    """Main CLI application for edge wake word detection."""

    def __init__(self):
        self.running = True
        self.detection_count = 0

    def mode_train(self, args):
        """
        Training mode: Record audio samples for custom wake word training.
        """
        print("\n" + "="*70)
        print("üéØ TRAINING MODE - Audio Sample Collection")
        print("="*70)

        recorder = AudioRecorder(output_dir=args.output_dir)

        try:
            # Test microphone first
            if args.test_mic:
                recorder.test_microphone(duration=3.0)

            # List devices if requested
            if args.list_devices:
                recorder.list_devices()
                return

            # Validate wake word
            if not args.wake_word:
                print("\n‚ùå Error: --wake-word is required for training mode")
                print("   Example: edge-wake-word train --wake-word 'hey edge'\n")
                return

            wake_word = args.wake_word.lower().replace(" ", "_")

            print(f"\nüìù Wake Word: '{args.wake_word}'")
            print(f"üìÅ Output Directory: {args.output_dir}")
            print(f"üé§ Sample Duration: {args.duration}s")
            print("\n" + "-"*70)

            # Training instructions
            print("\nüìö TRAINING DATA COLLECTION GUIDE:")
            print("\n  For best results with openWakeWord training:")
            print(f"  ‚Ä¢ Default: 5 samples for quick testing/demo")
            print(f"  ‚Ä¢ Production: Use --num-samples 50-100 for better accuracy")
            print(f"  ‚Ä¢ Vary your tone, speed, and distance from microphone")
            print(f"  ‚Ä¢ Optional: Record negative samples (NOT saying '{args.wake_word}')")
            print("\n  After collecting samples, use the openWakeWord Colab notebook")
            print("  to train your custom model:")
            print("  https://colab.research.google.com/drive/1q1oe2zOyZp7UsB3jJiQ1IFn8z5YfjwEb")
            print("\n" + "-"*70)

            # Record positive samples
            print("\nüü¢ STEP 1: Positive Samples")
            print(f"   Say the wake word clearly: '{args.wake_word}'\n")

            recorder.record_batch(
                wake_word=wake_word,
                num_samples=args.num_samples,
                duration=args.duration,
                sample_type="positive"
            )

            # Ask about negative samples
            if args.with_negatives:
                print("\nüî¥ STEP 2: Negative Samples")
                print(f"   Say anything EXCEPT '{args.wake_word}'\n")

                recorder.record_batch(
                    wake_word=wake_word,
                    num_samples=args.num_samples,
                    duration=args.duration,
                    sample_type="negative"
                )

            # Summary
            print("\n" + "="*70)
            print("‚úÖ TRAINING DATA COLLECTION COMPLETE!")
            print("="*70)
            print(f"\nüìÅ Your samples are saved in: {args.output_dir}/{wake_word}/")
            print("\nüìñ NEXT STEPS:")
            print("  1. Review your recordings to ensure quality")
            print("  2. Open the openWakeWord training Colab notebook:")
            print("     https://colab.research.google.com/drive/1q1oe2zOyZp7UsB3jJiQ1IFn8z5YfjwEb")
            print("  3. Upload your samples and follow the training guide")
            print("  4. Download the trained .tflite or .onnx model")
            print("  5. Test your model with: edge-wake-word test --model <path>\n")

        except KeyboardInterrupt:
            print("\n\n‚ö†Ô∏è  Training interrupted by user\n")
        except Exception as e:
            print(f"\n‚ùå Error: {e}\n", file=sys.stderr)
        finally:
            recorder.cleanup()

    def mode_train_local(self, args):
        """
        Local training mode: Train custom verifier model using recorded samples.
        """
        print("\n" + "="*70)
        print("üéì LOCAL TRAINING MODE - Custom Verifier Model")
        print("="*70)

        trainer = ModelTrainer(training_data_dir=args.data_dir)

        try:
            # Validate wake word
            if not args.wake_word:
                # List available wake words
                available = trainer.list_available_wake_words()
                if available:
                    print("\nüìÅ Available wake words with training data:")
                    for ww in available:
                        counts = trainer.get_sample_counts(ww)
                        print(f"  ‚Ä¢ {ww} ({counts['positive']} positive, {counts['negative']} negative)")
                    print("\nUsage: edge-wake-word train-local --wake-word <name>")
                else:
                    print("\n‚ùå No training data found.")
                    print("   Run: edge-wake-word train --wake-word \"your phrase\" first\n")
                return

            # Get sample counts
            counts = trainer.get_sample_counts(args.wake_word)

            if counts['positive'] == 0:
                print(f"\n‚ùå No training samples found for '{args.wake_word}'")
                print(f"   Run: edge-wake-word train --wake-word \"{args.wake_word}\" first\n")
                return

            print(f"\nüìù Wake Word: '{args.wake_word}'")
            print(f"üìä Training Data:")
            print(f"   ‚Ä¢ Positive samples: {counts['positive']}")
            print(f"   ‚Ä¢ Negative samples: {counts['negative']}")
            print(f"üéØ Base Model: {args.base_model}")
            print(f"‚öôÔ∏è  Verifier Threshold: {args.verifier_threshold}")

            if counts['positive'] < 3:
                print(f"\n‚ö†Ô∏è  Warning: Only {counts['positive']} positive samples.")
                print("   Minimum 3-5 samples recommended for best results.")

            print("\n" + "-"*70)
            print("Starting training...")
            print("-"*70 + "\n")

            # Train the model
            model_path = trainer.train_verifier(
                wake_word=args.wake_word,
                base_model=args.base_model,
                output_path=args.output if args.output else None,
                verifier_threshold=args.verifier_threshold
            )

            # Summary
            print("\n" + "="*70)
            print("‚úÖ TRAINING COMPLETE!")
            print("="*70)
            print(f"\nüìÅ Model saved to: {model_path}")
            print("\nüìñ NEXT STEPS:")
            print(f"  Test your model:")
            print(f"    edge-wake-word test-custom --wake-word \"{args.wake_word}\" \\")
            print(f"      --model \"{model_path}\" \\")
            print(f"      --base-model {args.base_model}")
            print()

        except Exception as e:
            print(f"\n‚ùå Error: {e}\n", file=sys.stderr)
            import traceback
            traceback.print_exc()

    def mode_test(self, args):
        """
        Test mode: Test wake word detection with visual feedback.
        """
        print("\n" + "="*70)
        print("üß™ TEST MODE - Wake Word Detection Testing")
        print("="*70)

        try:
            # Initialize detector
            detector_args = {
                "threshold": args.threshold,
                "on_detection": self._test_callback
            }

            # Add specific models if provided
            if args.model:
                detector_args["wake_words"] = [args.model]
            elif args.wake_words:
                detector_args["wake_words"] = args.wake_words

            print("\nInitializing wake word detector...")
            detector = WakeWordDetector(**detector_args)

            # Show loaded models
            models = detector.list_available_models()
            print(f"\n‚úì Loaded {len(models)} model(s):")
            for model in models:
                print(f"  ‚Ä¢ {model}")

            print(f"\n‚öôÔ∏è  Detection Threshold: {args.threshold}")
            print("\n" + "-"*70)
            print("STATUS: Listening for wake words...")
            print("TIP: Try different volumes, distances, and pronunciations")
            print("Press Ctrl+C to exit")
            print("-"*70 + "\n")

            # Set up signal handler
            signal.signal(signal.SIGINT, self._signal_handler)

            # Start detection
            detector.start()

            # Keep running
            while self.running:
                time.sleep(0.1)

        except KeyboardInterrupt:
            pass
        except Exception as e:
            print(f"\n‚ùå Error: {e}\n", file=sys.stderr)
        finally:
            if 'detector' in locals():
                detector.stop()
            print(f"\n\nüìä Test Results:")
            print(f"   Total detections: {self.detection_count}")
            print("   Goodbye! üëã\n")

    def mode_test_custom(self, args):
        """
        Test custom verifier model mode: Test locally-trained custom wake word.
        """
        print("\n" + "="*70)
        print("üéØ CUSTOM MODEL TEST - Testing Your Trained Wake Word")
        print("="*70)

        try:
            # Validate inputs
            if not args.wake_word:
                print("\n‚ùå Error: --wake-word is required")
                print("   Example: edge-wake-word test-custom --wake-word \"hey edge\" --model path/to/model.pkl\n")
                return

            if not args.model:
                # Try to find the model automatically
                wake_word_normalized = args.wake_word.lower().replace(" ", "_")
                auto_model_path = Path(args.data_dir) / wake_word_normalized / "models" / f"{wake_word_normalized}_verifier.pkl"

                if auto_model_path.exists():
                    args.model = str(auto_model_path)
                    print(f"\n‚úì Auto-detected model: {args.model}")
                else:
                    print("\n‚ùå Error: --model is required (model not found automatically)")
                    print(f"   Expected location: {auto_model_path}")
                    print("   Or specify: --model path/to/your/model.pkl\n")
                    return

            print(f"\nüìù Wake Word: '{args.wake_word}'")
            print(f"üìÅ Verifier Model: {args.model}")
            print(f"üéØ Base Model: {args.base_model}")
            print(f"‚öôÔ∏è  Verifier Threshold: {args.verifier_threshold}")

            # Initialize detector with custom verifier
            detector_args = {
                "wake_words": [args.base_model],
                "threshold": args.threshold,
                "on_detection": self._test_callback,
                "custom_verifier_models": {args.base_model: args.model},
                "custom_verifier_threshold": args.verifier_threshold
            }

            print("\nInitializing wake word detector with custom verifier...")
            detector = WakeWordDetector(**detector_args)

            print(f"\n‚úì Custom verifier loaded successfully!")

            print("\n" + "-"*70)
            print("STATUS: Listening for your custom wake word...")
            print(f"SAY: '{args.wake_word}'")
            print("TIP: Try the same tone/volume you used during recording")
            print("Press Ctrl+C to exit")
            print("-"*70 + "\n")

            # Set up signal handler
            signal.signal(signal.SIGINT, self._signal_handler)

            # Start detection
            detector.start()

            # Keep running
            while self.running:
                time.sleep(0.1)

        except KeyboardInterrupt:
            pass
        except Exception as e:
            print(f"\n‚ùå Error: {e}\n", file=sys.stderr)
            import traceback
            traceback.print_exc()
        finally:
            if 'detector' in locals():
                detector.stop()
            print(f"\n\nüìä Test Results:")
            print(f"   Total detections: {self.detection_count}")
            if self.detection_count == 0:
                print("\nüí° Tips if not detecting:")
                print("   ‚Ä¢ Try lowering --verifier-threshold (default: 0.3)")
                print("   ‚Ä¢ Record more training samples")
                print("   ‚Ä¢ Ensure similar recording conditions (distance, volume)")
            print("   Goodbye! üëã\n")

    def mode_run(self, args):
        """
        Run mode: Production wake word detection.
        """
        print("\n" + "="*70)
        print("üöÄ RUN MODE - Voice Assistant Active")
        print("="*70)

        try:
            # Initialize detector
            detector_args = {
                "threshold": args.threshold,
                "on_detection": self._production_callback
            }

            if args.wake_words:
                detector_args["wake_words"] = args.wake_words

            print("\nInitializing voice assistant...")
            detector = WakeWordDetector(**detector_args)

            models = detector.list_available_models()
            print(f"‚úì Active wake words: {', '.join(models)}")
            print(f"‚úì Detection threshold: {args.threshold}")

            if not args.quiet:
                print("\n" + "-"*70)
                print("STATUS: Voice assistant ready")
                print("-"*70 + "\n")

            # Set up signal handler
            signal.signal(signal.SIGINT, self._signal_handler)

            # Start detection
            detector.start()

            # Keep running
            while self.running:
                time.sleep(0.1)

        except KeyboardInterrupt:
            pass
        except Exception as e:
            print(f"\n‚ùå Error: {e}\n", file=sys.stderr)
        finally:
            if 'detector' in locals():
                detector.stop()
            if not args.quiet:
                print("\n\nShutting down... Goodbye! üëã\n")

    def _test_callback(self, wake_word: str, confidence: float):
        """Callback for test mode detections."""
        self.detection_count += 1
        print(f"\n{'='*70}")
        print(f"üéØ DETECTION #{self.detection_count}")
        print(f"{'='*70}")
        print(f"  Wake Word: {wake_word}")
        print(f"  Confidence: {confidence:.2%}")
        print(f"  Threshold: Passed" if confidence >= 0.5 else "  Threshold: Failed")
        print(f"{'='*70}\n")

    def _production_callback(self, wake_word: str, confidence: float):
        """Callback for production mode detections."""
        self.detection_count += 1
        print(f"\nüéôÔ∏è  ACTIVATED! [{wake_word}] (confidence: {confidence:.2%})")
        print("‚Üí Voice recognition would activate here")
        print("‚Üí Listening for your command...\n")

    def _signal_handler(self, signum, frame):
        """Handle Ctrl+C gracefully."""
        self.running = False


def main():
    """Main entry point for the CLI."""

    # Create main parser
    parser = argparse.ArgumentParser(
        prog="edge-wake-word",
        description="Voice assistant CLI for wake word detection on edge devices",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Test pre-trained wake words
  edge-wake-word test

  # Record samples for custom wake word
  edge-wake-word train --wake-word "hey edge"

  # Train model locally with recorded samples
  edge-wake-word train-local --wake-word "hey edge"

  # Test your custom trained model
  edge-wake-word test-custom --wake-word "hey edge"

  # Run in production mode
  edge-wake-word run --threshold 0.6

  # Test microphone
  edge-wake-word train --test-mic --list-devices
        """
    )

    # Create subparsers for different modes
    subparsers = parser.add_subparsers(dest="mode", help="Operation mode")

    # TRAIN mode
    train_parser = subparsers.add_parser(
        "train",
        help="Collect audio samples for custom wake word training"
    )
    train_parser.add_argument(
        "--wake-word",
        type=str,
        help="Wake word to train (e.g., 'hey edge')"
    )
    train_parser.add_argument(
        "--num-samples",
        type=int,
        default=5,
        help="Number of samples to record (default: 5, use 50-100 for production)"
    )
    train_parser.add_argument(
        "--duration",
        type=float,
        default=2.0,
        help="Duration of each sample in seconds (default: 2.0)"
    )
    train_parser.add_argument(
        "--output-dir",
        type=str,
        default="training_data",
        help="Output directory for samples (default: training_data)"
    )
    train_parser.add_argument(
        "--with-negatives",
        action="store_true",
        help="Also collect negative samples (not saying the wake word)"
    )
    train_parser.add_argument(
        "--test-mic",
        action="store_true",
        help="Test microphone before recording"
    )
    train_parser.add_argument(
        "--list-devices",
        action="store_true",
        help="List available audio devices and exit"
    )

    # TRAIN-LOCAL mode
    train_local_parser = subparsers.add_parser(
        "train-local",
        help="Train custom verifier model locally using recorded samples"
    )
    train_local_parser.add_argument(
        "--wake-word",
        type=str,
        help="Wake word to train (must have recorded samples)"
    )
    train_local_parser.add_argument(
        "--base-model",
        type=str,
        default="alexa",
        help="Base openWakeWord model to use (default: alexa)"
    )
    train_local_parser.add_argument(
        "--data-dir",
        type=str,
        default="training_data",
        help="Training data directory (default: training_data)"
    )
    train_local_parser.add_argument(
        "--output",
        type=str,
        help="Custom output path for the model (optional)"
    )
    train_local_parser.add_argument(
        "--verifier-threshold",
        type=float,
        default=0.3,
        help="Verifier activation threshold (default: 0.3)"
    )

    # TEST-CUSTOM mode
    test_custom_parser = subparsers.add_parser(
        "test-custom",
        help="Test locally-trained custom wake word"
    )
    test_custom_parser.add_argument(
        "--wake-word",
        type=str,
        required=True,
        help="Wake word to test (e.g., 'hey edge')"
    )
    test_custom_parser.add_argument(
        "--model",
        type=str,
        help="Path to trained verifier model (.pkl file, auto-detected if not specified)"
    )
    test_custom_parser.add_argument(
        "--base-model",
        type=str,
        default="alexa",
        help="Base openWakeWord model used during training (default: alexa)"
    )
    test_custom_parser.add_argument(
        "--data-dir",
        type=str,
        default="training_data",
        help="Training data directory for auto-detection (default: training_data)"
    )
    test_custom_parser.add_argument(
        "--threshold",
        type=float,
        default=0.5,
        help="Base model detection threshold (default: 0.5)"
    )
    test_custom_parser.add_argument(
        "--verifier-threshold",
        type=float,
        default=0.3,
        help="Verifier confidence threshold (default: 0.3)"
    )

    # TEST mode
    test_parser = subparsers.add_parser(
        "test",
        help="Test wake word detection with visual feedback"
    )
    test_parser.add_argument(
        "--model",
        type=str,
        help="Path to custom model file (.tflite or .onnx)"
    )
    test_parser.add_argument(
        "--wake-words",
        nargs="+",
        help="Specific wake words to test (e.g., alexa hey_jarvis)"
    )
    test_parser.add_argument(
        "--threshold",
        type=float,
        default=0.5,
        help="Detection confidence threshold (default: 0.5)"
    )

    # RUN mode
    run_parser = subparsers.add_parser(
        "run",
        help="Run wake word detection in production mode"
    )
    run_parser.add_argument(
        "--wake-words",
        nargs="+",
        help="Wake words to detect (default: all available)"
    )
    run_parser.add_argument(
        "--threshold",
        type=float,
        default=0.5,
        help="Detection confidence threshold (default: 0.5)"
    )
    run_parser.add_argument(
        "--quiet",
        action="store_true",
        help="Suppress status messages"
    )

    # Parse arguments
    args = parser.parse_args()

    # Show help if no mode specified
    if not args.mode:
        parser.print_help()
        return

    # Create app instance
    app = EdgeWakeWord()

    # Run the appropriate mode
    if args.mode == "train":
        app.mode_train(args)
    elif args.mode == "train-local":
        app.mode_train_local(args)
    elif args.mode == "test":
        app.mode_test(args)
    elif args.mode == "test-custom":
        app.mode_test_custom(args)
    elif args.mode == "run":
        app.mode_run(args)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nInterrupted by user. Exiting gracefully...\n")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {e}\n", file=sys.stderr)
        sys.exit(1)
